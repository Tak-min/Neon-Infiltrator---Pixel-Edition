<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Infiltrator - Pixel Edition</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            color: #00ffff;
        }
        
        #gameContainer {
            border: 2px solid #00ffff;
            border-radius: 8px;
            box-shadow: 0 0 20px #00ffff;
            background: #001122;
            position: relative;
        }
        
        #gameCanvas {
            display: block;
            background: linear-gradient(45deg, #001122, #002244);
            image-rendering: pixelated; /* ドット絵風のレンダリング */
            image-rendering: crisp-edges;
        }

        #hpContainer {
            display: flex;
            align-items: center;
            margin-top: 5px;
        }

        #hpBar {
            width: 100px;
            height: 10px;
            background-color: #444;
            border: 1px solid #00ffff;
            margin-left: 5px;
        }

        #hpBarInner {
            width: 100%;
            height: 100%;
            background-color: #00ff00;
            transition: width 0.2s;
        }
        
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            text-shadow: 0 0 10px #00ffff;
        }
        
        #minimap {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 150px;
            height: 150px;
            border: 2px solid #00ffff;
            background: rgba(0, 17, 34, 0.8);
            z-index: 100;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        
        #instructions {
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 100;
            font-size: 12px;
            max-width: 300px;
            text-shadow: 0 0 5px #00ffff;
        }
        
        #status {
            position: absolute;
            top: 170px;
            right: 10px;
            z-index: 100;
            text-align: right;
            text-shadow: 0 0 10px #ff0080;
        }
        
        #noiseLevel {
            position: absolute;
            bottom: 80px;
            left: 10px;
            z-index: 100;
            text-shadow: 0 0 5px #ffff00;
        }

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 10, 20, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }

        .screen.active {
            display: flex;
        }

        .screen h1 {
            font-size: 48px;
            color: #00ffff;
            text-shadow: 0 0 15px #00ffff;
            margin-bottom: 40px;
        }

        .menu-button {
            background: transparent;
            border: 2px solid #00ffff;
            color: #00ffff;
            padding: 15px 30px;
            font-family: 'Courier New', monospace;
            font-size: 24px;
            margin: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 250px;
            text-align: center;
        }

        .menu-button:hover {
            background: #00ffff;
            color: #001122;
            box-shadow: 0 0 20px #00ffff;
        }

        #tutorialScreen table {
            border-collapse: collapse;
            margin-bottom: 20px;
            color: #fff;
        }

        #tutorialScreen th, #tutorialScreen td {
            border: 1px solid #00ffff;
            padding: 8px 15px;
            text-align: center;
        }

        #tutorialScreen th {
            color: #00ffff;
        }
    </style>
</head>
<body>
    <div id="titleScreen" class="screen active">
        <h1>Neon Infiltrator</h1>
        <button id="startButton" class="menu-button">Start Game</button>
        <button id="tutorialButton" class="menu-button">Tutorial</button>
    </div>

    <div id="tutorialScreen" class="screen">
        <h1>Tutorial</h1>
        <table id="levelTable">
            <thead>
                <tr>
                    <th>Level</th>
                    <th>Target Orbs</th>
                </tr>
            </thead>
            <tbody>
                <!-- Generated by JS -->
            </tbody>
        </table>
        <div style="color: #fff; margin: 20px 0; max-width: 600px; text-align: left;">
            <h3 style="color: #00ffff;">Controls:</h3>
            <p>WASD: Move | SHIFT: Run (makes noise)</p>
            <p>SPACE: Stealth mode | E: Hack | Q: EMP Grenade</p>
            <p>Blue dots: Data orbs | Green areas: Safe zones</p>
            <p>Avoid enemy sight and sound detection!</p>
        </div>
        <button id="tutorialBackButton" class="menu-button">Back</button>
    </div>

    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <canvas id="minimap" width="150" height="150"></canvas>
        <div id="ui">
            <div>Score: <span id="score">0</span></div>
            <div>Orbs Collected: <span id="data">0</span>/<span id="totalData">0</span></div>
            <div>Level: <span id="level">1</span></div>
            <div id="hpContainer">
                <span>HP:</span>
                <div id="hpBar">
                    <div id="hpBarInner"></div>
                </div>
            </div>
        </div>
        <div id="status">
            <div id="alertStatus">Status: Stealth Mode</div>
            <div id="abilities">
                <div>Stealth: <span id="stealth">Ready</span></div>
                <div>Hack: <span id="hack">Ready</span></div>
                <div>EMP Grenade: <span id="emp">x3</span></div>
            </div>
        </div>
        <div id="noiseLevel">
            Noise Level: <span id="noise">Silent</span>
        </div>
        <!-- <div id="instructions">
            WASD: Move | SHIFT: Run (makes noise)<br>
            SPACE: Stealth mode | E: Hack | Q: EMP Grenade<br>
            Blue dots: Data orbs | Green areas: Safe zones<br>
            Avoid enemy sight and sound detection!
        </div> -->
    </div>

    <script>
        class EnhancedNeonInfiltrator {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.minimapCanvas = document.getElementById('minimap');
                this.minimapCtx = this.minimapCanvas.getContext('2d');
                
                // ドット絵風にするための設定
                this.ctx.imageSmoothingEnabled = false;
                this.minimapCtx.imageSmoothingEnabled = false;

                this.width = this.canvas.width;
                this.height = this.canvas.height;
                
                // レベルシステムの定義
                this.levelTargets = [5, 25, 75, 165, 345, 525, 775, 1000, 1500, 2000];
                this.currentLevel = 1;
                this.totalOrbsCollected = 0;

                this.setupMenus();
                this.init();
            }

            setupMenus() {
                // レベル表の生成
                this.generateLevelTable();
                
                // ボタンイベントリスナーの設定
                document.getElementById('startButton').addEventListener('click', () => {
                    this.showScreen('game');
                    this.startGame();
                });
                
                document.getElementById('tutorialButton').addEventListener('click', () => {
                    this.showScreen('tutorial');
                });
                
                document.getElementById('tutorialBackButton').addEventListener('click', () => {
                    this.showScreen('title');
                });
            }

            generateLevelTable() {
                const tbody = document.querySelector('#levelTable tbody');
                tbody.innerHTML = '';
                this.levelTargets.forEach((target, index) => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>Level ${index + 1}</td>
                        <td>${target} orbs</td>
                    `;
                    tbody.appendChild(row);
                });
            }

            showScreen(screenName) {
                // すべての画面を非アクティブにする
                document.querySelectorAll('.screen').forEach(screen => {
                    screen.classList.remove('active');
                });
                
                // ゲームコンテナの表示/非表示
                const gameContainer = document.getElementById('gameContainer');
                if (screenName === 'game') {
                    gameContainer.style.display = 'block';
                } else {
                    gameContainer.style.display = 'none';
                    // 指定された画面をアクティブにする
                    document.getElementById(screenName + 'Screen').classList.add('active');
                }
            }

            init(isRestart = false) {
                // ゲーム状態
                this.gameState = 'menu'; // menu, playing, gameOver, areaClear
                this.exit = null;

                // ワールド管理
                this.camera = { x: 0, y: 0 };
                this.areaSize = 1200;
                this.areas = new Map();
                this.currentAreaKey = null;
                
                // プレイヤー
                this.player = {
                    x: 100,
                    y: 100,
                    size: 10, // サイズを調整
                    baseSpeed: 2.0, // 速度を調整
                    runSpeed: 3.5, // 速度を調整
                    currentSpeed: 2.0,
                    stealth: false,
                    stealthCooldown: 0,
                    hackCooldown: 0,
                    empGrenades: 3,
                    empCooldown: 0,
                    noiseLevel: 0,
                    isRunning: false,
                    hp: 100,
                    maxHp: 100
                };
                
                if (!isRestart) {
                    this.score = 0;
                    this.totalOrbsCollected = 0;
                    this.currentLevel = 1;
                }
                this.currentArea = 1;
                
                this.dataCollected = 0;
                this.totalDataInArea = 0;
                this.alertLevel = 0;
                this.gameTime = 0;
                this.globalAlertLevel = 0;
                
                this.keys = {};
                this.enemies = [];
                this.dataPoints = [];
                this.obstacles = [];
                this.lights = [];
                this.safeZones = [];
                this.securityCameras = [];

                if (this.gameLoopId) {
                    cancelAnimationFrame(this.gameLoopId);
                }
                
                this.setupEventListeners();
                this.gameLoop();
            }

            startGame() {
                this.player.x = 100;
                this.player.y = 100;
                this.player.hp = this.player.maxHp;
                this.dataCollected = 0;
                this.exit = null;
                this.currentAreaKey = `${Math.floor(this.player.x / this.areaSize)},${Math.floor(this.player.y / this.areaSize)}`;
                this.generateCurrentArea();
                this.gameState = 'playing';
            }
            
            generateCurrentArea() {
                const areaKey = this.currentAreaKey;
                
                if (!this.areas.has(areaKey)) {
                    const area = this.generateAreaData(areaKey);
                    this.areas.set(areaKey, area);
                }
                
                // 現在のエリアのデータを読み込み
                this.loadArea(areaKey);
                this.dataCollected = 0; // エリア移動時にリセット
            }
            
            generateAreaData(areaKey) {
                const [areaX, areaY] = areaKey.split(',').map(Number);
                const baseX = areaX * this.areaSize;
                const baseY = areaY * this.areaSize;
                
                // シード値でランダム生成を制御
                const seed = this.hashCode(areaKey);
                const rng = this.seededRandom(seed);
                
                const area = {
                    obstacles: [],
                    enemies: [],
                    dataPoints: [],
                    lights: [],
                    safeZones: [],
                    cameras: [],
                    difficulty: Math.abs(areaX) + Math.abs(areaY) + 1,
                    exit: null
                };
                
                // より複雑な建物レイアウト生成
                this.generateBuildingComplex(area, baseX, baseY, rng);
                
                // 敵配置（パトロールルート付き）
                this.generateEnemiesWithPatrols(area, baseX, baseY, rng);
                
                // セキュリティカメラ
                this.generateSecurityCameras(area, baseX, baseY, rng);
                
                // データポイントと安全地帯
                this.generateObjectives(area, baseX, baseY, rng);
                
                // 照明システム
                this.generateLightingSystem(area, baseX, baseY, rng);
                
                return area;
            }
            
            generateBuildingComplex(area, baseX, baseY, rng) {
                // メインビル群
                const buildingCount = 8 + Math.floor(rng() * 6);
                
                for (let i = 0; i < buildingCount; i++) {
                    const building = {
                        x: baseX + rng() * (this.areaSize - 200) + 100,
                        y: baseY + rng() * (this.areaSize - 200) + 100,
                        width: 60 + rng() * 120,
                        height: 60 + rng() * 120,
                        type: 'building'
                    };
                    area.obstacles.push(building);
                    
                    // 建物に付属する小さな構造物
                    const annexCount = Math.floor(rng() * 3);
                    for (let j = 0; j < annexCount; j++) {
                        area.obstacles.push({
                            x: building.x + (rng() - 0.5) * 150,
                            y: building.y + (rng() - 0.5) * 150,
                            width: 20 + rng() * 40,
                            height: 20 + rng() * 40,
                            type: 'annex'
                        });
                    }
                }
                
                // 壁と通路システム
                const wallCount = 12 + Math.floor(rng() * 8);
                for (let i = 0; i < wallCount; i++) {
                    const isHorizontal = rng() > 0.5;
                    area.obstacles.push({
                        x: baseX + rng() * (this.areaSize - 100),
                        y: baseY + rng() * (this.areaSize - 100),
                        width: isHorizontal ? 80 + rng() * 120 : 15,
                        height: isHorizontal ? 15 : 80 + rng() * 120,
                        type: 'wall'
                    });
                }
            }
            
            generateEnemiesWithPatrols(area, baseX, baseY, rng) {
                const enemyCount = 4 + Math.floor(area.difficulty * 2) + Math.floor(rng() * 4);
                
                for (let i = 0; i < enemyCount; i++) {
                    let startX, startY;
                    do {
                        startX = baseX + 100 + rng() * (this.areaSize - 200);
                        startY = baseY + 100 + rng() * (this.areaSize - 200);
                    } while (!this.isPositionValidInArea(startX, startY, 14, area.obstacles));

                    // パトロールポイント生成
                    const patrolPoints = [];
                    const patrolCount = 2 + Math.floor(rng() * 4);
                    
                    for (let j = 0; j < patrolCount; j++) {
                        patrolPoints.push({
                            x: startX + (rng() - 0.5) * 200,
                            y: startY + (rng() - 0.5) * 200
                        });
                    }
                    
                    const enemyType = rng() > 0.7 ? 'heavy' : rng() > 0.4 ? 'scout' : 'guard';
                    
                    area.enemies.push({
                        x: startX,
                        y: startY,
                        size: enemyType === 'heavy' ? 14 : enemyType === 'scout' ? 8 : 12,
                        baseSpeed: enemyType === 'scout' ? 1.8 : enemyType === 'heavy' ? 0.8 : 1.2,
                        currentSpeed: 0,
                        angle: rng() * Math.PI * 2,
                        viewDistance: enemyType === 'scout' ? 120 : enemyType === 'heavy' ? 60 : 80,
                        viewAngle: enemyType === 'scout' ? Math.PI / 2 : Math.PI / 3,
                        hearingRange: enemyType === 'scout' ? 80 : 60,
                        alertState: 0,
                        suspicionLevel: 0,
                        patrolPoints: patrolPoints,
                        currentPatrolTarget: 0,
                        type: enemyType,
                        lastKnownPlayerPos: null,
                        searchTimer: 0,
                        turnTimer: 0,
                        idleTimer: 0,
                        collisionCooldown: 0,
                        damage: enemyType === 'heavy' ? 25 : 15,
                        attackCooldown: 0
                    });
                }
            }
            
            generateSecurityCameras(area, baseX, baseY, rng) {
                const cameraCount = 2 + Math.floor(area.difficulty * 1.5);
                
                for (let i = 0; i < cameraCount; i++) {
                    let x, y;
                    do {
                        x = baseX + rng() * this.areaSize;
                        y = baseY + rng() * this.areaSize;
                    } while (!this.isPositionValidInArea(x, y, 12, area.obstacles));

                    area.cameras.push({
                        x: x,
                        y: y,
                        angle: rng() * Math.PI * 2,
                        viewDistance: 100,
                        viewAngle: Math.PI / 4,
                        rotationSpeed: 0.02,
                        rotationRange: Math.PI / 2,
                        baseAngle: rng() * Math.PI * 2,
                        alertState: 0,
                        disabled: false,
                        disableTimer: 0
                    });
                }
            }
            
            generateObjectives(area, baseX, baseY, rng) {
                const objectiveCount = 5 + Math.floor(rng() * 4);
                area.totalData = 0;
                for (let i = 0; i < objectiveCount; i++) {
                    let x, y;
                    do {
                        x = baseX + 50 + rng() * (this.areaSize - 100);
                        y = baseY + 50 + rng() * (this.areaSize - 100);
                    } while (!this.isPositionValidInArea(x, y, 10, area.obstacles));

                    const dataValue = 10 + Math.floor(rng() * 11);
                    area.dataPoints.push({
                        x: x,
                        y: y,
                        size: 10,
                        dataValue: dataValue,
                        collected: false,
                        pulse: rng() * Math.PI * 2
                    });
                    area.totalData += dataValue;
                }
            }
            
            generateLightingSystem(area, baseX, baseY, rng) {
                const lightCount = 15 + Math.floor(rng() * 10);
                
                for (let i = 0; i < lightCount; i++) {
                    area.lights.push({
                        x: baseX + rng() * this.areaSize,
                        y: baseY + rng() * this.areaSize,
                        radius: 30 + rng() * 60,
                        color: this.getRandomNeonColor(rng),
                        intensity: 0.2 + rng() * 0.5,
                        flicker: rng() * 0.15,
                        type: rng() > 0.8 ? 'strobe' : 'normal'
                    });
                }
            }
            
            loadArea(areaKey, isCurrent) {
                const area = this.areas.get(areaKey);
                if (!area) return;
                
                this.obstacles.push(...area.obstacles);
                this.enemies.push(...area.enemies);
                this.dataPoints.push(...area.dataPoints);
                this.lights.push(...area.lights);
                this.safeZones.push(...area.safeZones);
                this.securityCameras.push(...area.cameras);
                
                if (isCurrent) {
                    this.exit = area.exit;
                    this.totalDataInArea = this.dataPoints.filter(d => !d.collected).length;
                    const areaCoords = areaKey.split(',').map(Number);
                    this.currentArea = Math.abs(areaCoords[0]) + Math.abs(areaCoords[1]) + 1;
                }
            }
            
            setupEventListeners() {
                this.keydownHandler = (e) => {
                    const key = e.key.toLowerCase();
                    if (this.gameState === 'playing') {
                        this.keys[key] = true;
                        if (e.key === ' ') {
                            e.preventDefault();
                            this.activateStealth();
                        }
                        if (key === 'e') this.hack();
                        if (key === 'q') this.useEMPGrenade();
                    } else if (this.gameState === 'gameOver' && e.key === 'Enter') {
                        this.init(true);
                        this.startGame();
                    } else if (this.gameState === 'areaClear' && e.key === 'Enter') {
                        this.nextLevel();
                    }
                };

                this.keyupHandler = (e) => {
                    if (this.gameState === 'playing') {
                        this.keys[e.key.toLowerCase()] = false;
                    }
                };

                document.removeEventListener('keydown', this.keydownHandler);
                document.removeEventListener('keyup', this.keyupHandler);
                document.addEventListener('keydown', this.keydownHandler);
                document.addEventListener('keyup', this.keyupHandler);
            }
            
            activateStealth() {
                if (this.player.stealthCooldown <= 0 && !this.isInSafeZone()) {
                    this.player.stealth = true;
                    this.player.stealthCooldown = 600; // 10秒クールダウン
                    setTimeout(() => {
                        this.player.stealth = false;
                    }, 180); // 3秒間透明
                }
            }
            
            hack() {
                if (this.player.hackCooldown <= 0) {
                    let hackedSomething = false;
                    
                    // 近くの敵をハック
                    this.enemies.forEach(enemy => {
                        const dist = this.distance(this.player, enemy);
                        if (dist < 100) {
                            enemy.alertState = -120; // 2秒間無力化
                            hackedSomething = true;
                        }
                    });
                    
                    // 近くのカメラをハック
                    this.securityCameras.forEach(camera => {
                        const dist = this.distance(this.player, camera);
                        if (dist < 80 && !camera.disabled) {
                            camera.disabled = true;
                            camera.disableTimer = 300; // 5秒間無効化
                            hackedSomething = true;
                        }
                    });
                    
                    if (hackedSomething) {
                        this.player.hackCooldown = 360; // 6秒クールダウン
                    }
                }
            }
            
            useEMPGrenade() {
                if (this.player.empGrenades > 0 && this.player.empCooldown <= 0) {
                    this.player.empGrenades--;
                    this.player.empCooldown = 900; // 15秒クールダウン
                    
                    // 大範囲の電子機器を無効化
                    this.enemies.forEach(enemy => {
                        const dist = this.distance(this.player, enemy);
                        if (dist < 150) {
                            enemy.alertState = -180; // 3秒間無力化
                            enemy.suspicionLevel = 0;
                        }
                    });
                    
                    this.securityCameras.forEach(camera => {
                        const dist = this.distance(this.player, camera);
                        if (dist < 150) {
                            camera.disabled = true;
                            camera.disableTimer = 600; // 10秒間無効化
                        }
                    });
                    
                    // EMPエフェクト
                    this.createEMPEffect();
                }
            }
            
            update() {
                this.gameTime++;

                // エリア遷移チェック
                this.updateLoadedAreas();
                
                // プレイヤー更新
                this.updatePlayer();
                
                // 敵AI更新
                this.updateEnemies();
                
                // セキュリティカメラ更新
                this.updateSecurityCameras();
                
                // データポイントチェック
                this.checkDataCollection();

                // プレイヤーが捕まったかチェック
                this.checkPlayerCaught();

                // 出口に到達したかチェック
                this.checkExit();
                
                // カメラ更新
                this.updateCamera();
                
                // クールダウン更新
                this.updateCooldowns();
                
                // ノイズレベル減衰
                this.player.noiseLevel *= 0.95;
            }
            
            updateLoadedAreas() {
                const playerAreaX = Math.floor(this.player.x / this.areaSize);
                const playerAreaY = Math.floor(this.player.y / this.areaSize);
                const newAreaKey = `${playerAreaX},${playerAreaY}`;

                if (newAreaKey !== this.currentAreaKey) {
                    this.currentAreaKey = newAreaKey;
                }

                this.obstacles = [];
                this.enemies = [];
                this.dataPoints = [];
                this.lights = [];
                this.safeZones = [];
                this.securityCameras = [];
                this.exit = null;

                for (let y = playerAreaY - 1; y <= playerAreaY + 1; y++) {
                    for (let x = playerAreaX - 1; x <= playerAreaX + 1; x++) {
                        const areaKey = `${x},${y}`;
                        if (!this.areas.has(areaKey)) {
                            const area = this.generateAreaData(areaKey);
                            this.areas.set(areaKey, area);
                        }
                        this.loadArea(areaKey, areaKey === this.currentAreaKey);
                    }
                }
            }
            
            nextLevel() {
                const currentAreaKey = `${Math.floor(this.player.x / this.areaSize)},${Math.floor(this.player.y / this.areaSize)}`;
                this.areas.get(currentAreaKey).exit = this.exit; // 出口情報を保存

                // 仮に右のエリアに移動
                this.player.x += this.areaSize;
                this.player.x = Math.floor(this.player.x / this.areaSize) * this.areaSize + 100;
                this.player.y = Math.floor(this.player.y / this.areaSize) * this.areaSize + 100;

                this.exit = null;
                this.currentAreaKey = `${Math.floor(this.player.x / this.areaSize)},${Math.floor(this.player.y / this.areaSize)}`;
                this.updateLoadedAreas();
                this.gameState = 'playing';
            }

            checkPlayerCaught() {
                if (this.player.stealth || this.isInSafeZone()) return;

                for (const enemy of this.enemies) {
                    if (enemy.alertState >= 0 && this.distance(this.player, enemy) < (this.player.size + enemy.size) / 2) {
                        if (enemy.attackCooldown <= 0) {
                            this.player.hp -= enemy.damage;
                            enemy.attackCooldown = 60; // 1秒間の攻撃クールダウン
                            if (this.player.hp <= 0) {
                                this.gameState = 'gameOver';
                                return;
                            }
                        }
                    }
                }
            }

            checkExit() {
                if (!this.exit) return;
                if (this.distance(this.player, this.exit) < (this.player.size + this.exit.size) / 2) {
                    this.gameState = 'areaClear';
                }
            }

            createExit() {
                const areaKey = `${Math.floor(this.player.x / this.areaSize)},${Math.floor(this.player.y / this.areaSize)}`;
                const area = this.areas.get(areaKey);
                const rng = this.seededRandom(this.hashCode(areaKey + "exit"));
                const baseX = Math.floor(this.player.x / this.areaSize) * this.areaSize;
                const baseY = Math.floor(this.player.y / this.areaSize) * this.areaSize;

                let exitPos = { x: 0, y: 0 };
                do {
                    exitPos.x = baseX + 50 + rng() * (this.areaSize - 100);
                    exitPos.y = baseY + 50 + rng() * (this.areaSize - 100);
                } while (!this.isValidPosition(exitPos.x, exitPos.y, 30));

                this.exit = { ...exitPos, size: 30, pulse: 0 };
                area.exit = this.exit;
            }

            updatePlayer() {
                let dx = 0, dy = 0;
                this.player.isRunning = this.keys['shift'];
                
                if (this.keys['w'] || this.keys['arrowup']) dy = -1;
                if (this.keys['s'] || this.keys['arrowdown']) dy = 1;
                if (this.keys['a'] || this.keys['arrowleft']) dx = -1;
                if (this.keys['d'] || this.keys['arrowright']) dx = 1;
                
                // 速度計算
                this.player.currentSpeed = this.player.isRunning ? this.player.runSpeed : this.player.baseSpeed;
                
                // ステルス中は速度減少
                if (this.player.stealth) {
                    this.player.currentSpeed *= 0.6;
                }
                
                // 対角線移動の正規化
                if (dx !== 0 && dy !== 0) {
                    dx *= 0.707;
                    dy *= 0.707;
                }
                
                // ノイズ生成
                if (dx !== 0 || dy !== 0) {
                    const moveNoise = this.player.isRunning ? 8 : 2;
                    this.player.noiseLevel = Math.min(10, this.player.noiseLevel + moveNoise * 0.1);
                }
                
                // 移動と衝突判定
                const newX = this.player.x + dx * this.player.currentSpeed;
                const newY = this.player.y + dy * this.player.currentSpeed;
                
                if (this.isValidPosition(newX, this.player.y, this.player.size)) {
                    this.player.x = newX;
                }
                if (this.isValidPosition(this.player.x, newY, this.player.size)) {
                    this.player.y = newY;
                }
            }
            
            updateEnemies() {
                this.enemies.forEach(enemy => {
                    this.updateEnemyAI(enemy);
                });
            }
            
            updateEnemyAI(enemy) {
                if (enemy.collisionCooldown > 0) {
                    enemy.collisionCooldown--;
                }
                // アラート状態更新
                if (enemy.alertState > 0) {
                    enemy.alertState--;
                    enemy.suspicionLevel = Math.max(0, enemy.suspicionLevel - 0.5);
                } else if (enemy.alertState < 0) {
                    enemy.alertState++;
                    return; // ハックされて無力化中
                }
                if (enemy.attackCooldown > 0) {
                    enemy.attackCooldown--;
                }
                
                // プレイヤー検出
                const canSeePlayer = this.checkEnemyDetection(enemy);
                const canHearPlayer = this.checkEnemyHearing(enemy);
                
                if (canSeePlayer || canHearPlayer) {
                    enemy.alertState = 300; // 5秒間アラート
                    enemy.suspicionLevel = Math.min(100, enemy.suspicionLevel + (canSeePlayer ? 10 : 5));
                    enemy.lastKnownPlayerPos = { x: this.player.x, y: this.player.y };
                    this.globalAlertLevel = Math.max(this.globalAlertLevel, 120);
                }
                
                // AI状態に基づく行動
                if (enemy.alertState > 0 && enemy.lastKnownPlayerPos) {
                    this.enemySearchBehavior(enemy);
                } else {
                    this.enemyPatrolBehavior(enemy);
                }
                
                // 移動実行
                this.moveEnemy(enemy);
            }
            
            checkEnemyDetection(enemy) {
                if (this.player.stealth) return false;
                
                const dist = this.distance(enemy, this.player);
                if (dist <= enemy.viewDistance) {
                    const angleToPlayer = Math.atan2(this.player.y - enemy.y, this.player.x - enemy.x);
                    let angleDiff = Math.abs(angleToPlayer - enemy.angle);
                    if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;
                    
                    if (angleDiff <= enemy.viewAngle / 2) {
                        return !this.hasLineOfSightBlocked(enemy, this.player);
                    }
                }
                return false;
            }
            
            checkEnemyHearing(enemy) {
                const dist = this.distance(enemy, this.player);
                const hearingThreshold = this.player.noiseLevel * (this.isInSafeZone() ? 0.5 : 1);
                return dist <= enemy.hearingRange && hearingThreshold > 3;
            }
            
            enemyPatrolBehavior(enemy) {
                if (enemy.patrolPoints.length === 0) {
                    // パトロールポイントがない場合はランダム移動
                    if (enemy.turnTimer <= 0) {
                        enemy.angle += (Math.random() - 0.5) * 1.0;
                        enemy.turnTimer = 60 + Math.random() * 120;
                    }
                    enemy.currentSpeed = enemy.baseSpeed * 0.5;
                } else {
                    // パトロールポイントに向かう
                    const target = enemy.patrolPoints[enemy.currentPatrolTarget];
                    const dist = this.distance(enemy, target);
                    
                    if (dist < 20) {
                        enemy.currentPatrolTarget = (enemy.currentPatrolTarget + 1) % enemy.patrolPoints.length;
                        enemy.idleTimer = 120; // 2秒待機
                    }
                    
                    if (enemy.idleTimer > 0) {
                        enemy.idleTimer--;
                        enemy.currentSpeed = 0;
                    } else {
                        enemy.angle = Math.atan2(target.y - enemy.y, target.x - enemy.x);
                        enemy.currentSpeed = enemy.baseSpeed;
                    }
                }
                
                enemy.turnTimer--;
            }
            
            enemySearchBehavior(enemy) {
                const target = enemy.lastKnownPlayerPos;
                const dist = this.distance(enemy, target);
                
                if (dist < 30) {
                    // プレイヤーの最後の位置に到達、周囲を捜索
                    enemy.searchTimer++;
                    if (enemy.searchTimer % 60 === 0) {
                        enemy.angle += Math.PI / 4; // 45度ずつ回転
                    }
                    enemy.currentSpeed = enemy.baseSpeed * 0.3;
                    
                    if (enemy.searchTimer > 300) { // 5秒後に諦める
                        enemy.lastKnownPlayerPos = null;
                        enemy.searchTimer = 0;
                        enemy.suspicionLevel = 0;
                    }
                } else {
                    // 最後の位置に向かう
                    enemy.angle = Math.atan2(target.y - enemy.y, target.x - enemy.x);
                    enemy.currentSpeed = enemy.baseSpeed * 1.5; // 急いで移動
                }
            }
            
            moveEnemy(enemy) {
                const newX = enemy.x + Math.cos(enemy.angle) * enemy.currentSpeed;
                const newY = enemy.y + Math.sin(enemy.angle) * enemy.currentSpeed;
                
                if (enemy.collisionCooldown === 0 && !this.isValidPosition(newX, newY, enemy.size)) {
                    enemy.collisionCooldown = 30; // 0.5秒間当たり判定を無効化
                    if (enemy.alertState > 0) {
                        // アラート中は迂回しようとする
                        enemy.angle += (Math.random() > 0.5 ? 1 : -1) * Math.PI / 2;
                    } else {
                        // パトロール中は向きを変える
                        enemy.angle += Math.PI + (Math.random() - 0.5) * Math.PI / 2;
                    }
                } else {
                    enemy.x = newX;
                    enemy.y = newY;
                }
            }
            
            updateSecurityCameras() {
                this.securityCameras.forEach(camera => {
                    if (camera.disabled) {
                        camera.disableTimer--;
                        if (camera.disableTimer <= 0) {
                            camera.disabled = false;
                        }
                        return;
                    }
                    
                    // カメラ回転
                    const rotationOffset = Math.sin(this.gameTime * camera.rotationSpeed) * camera.rotationRange;
                    camera.angle = camera.baseAngle + rotationOffset;
                    
                    // プレイヤー検出
                    if (!this.player.stealth && this.checkCameraDetection(camera)) {
                        camera.alertState = 120;
                        this.globalAlertLevel = Math.max(this.globalAlertLevel, 60);
                    }
                    
                    if (camera.alertState > 0) camera.alertState--;
                });
            }
            
            checkCameraDetection(camera) {
                const dist = this.distance(camera, this.player);
                if (dist <= camera.viewDistance) {
                    const angleToPlayer = Math.atan2(this.player.y - camera.y, this.player.x - camera.x);
                    let angleDiff = Math.abs(angleToPlayer - camera.angle);
                    if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;
                    
                    if (angleDiff <= camera.viewAngle / 2) {
                        return !this.hasLineOfSightBlocked(camera, this.player);
                    }
                }
                return false;
            }
            
            checkDataCollection() {
                let collectedCountInArea = 0;
                let totalDataInCurrentArea = 0;

                this.dataPoints.forEach(data => {
                    const dataAreaX = Math.floor(data.x / this.areaSize);
                    const dataAreaY = Math.floor(data.y / this.areaSize);
                    const currentAreaX = Math.floor(this.player.x / this.areaSize);
                    const currentAreaY = Math.floor(this.player.y / this.areaSize);

                    if (dataAreaX === currentAreaX && dataAreaY === currentAreaY) {
                        totalDataInCurrentArea++;
                        if (data.collected) {
                            collectedCountInArea++;
                        } else {
                            data.pulse += 0.08;
                            const dist = this.distance(this.player, data);
                            if (dist < 25) {
                                data.collected = true;
                                this.dataCollected++;
                                this.totalOrbsCollected++;
                                this.score += data.dataValue;
                                collectedCountInArea++;
                                
                                // レベルアップチェック
                                this.checkLevelUp();
                            }
                        }
                    }
                });

                this.totalDataInArea = totalDataInCurrentArea;
                
                if (this.totalDataInArea > 0 && collectedCountInArea === this.totalDataInArea && !this.exit) {
                    this.createExit();
                }
            }

            checkLevelUp() {
                if (this.currentLevel <= this.levelTargets.length) {
                    const targetForCurrentLevel = this.levelTargets[this.currentLevel - 1];
                    if (this.totalOrbsCollected >= targetForCurrentLevel) {
                        this.currentLevel++;
                        // レベルアップ時のボーナススコア
                        this.score += 1000;
                    }
                }
            }
            
            isInSafeZone() {
                return this.safeZones.some(zone => {
                    const dist = this.distance(this.player, zone);
                    return dist <= zone.radius;
                });
            }
            
            updateCamera() {
                this.camera.x = this.player.x - this.width / 2;
                this.camera.y = this.player.y - this.height / 2;
            }
            
            updateCooldowns() {
                if (this.player.stealthCooldown > 0) this.player.stealthCooldown--;
                if (this.player.hackCooldown > 0) this.player.hackCooldown--;
                if (this.player.empCooldown > 0) this.player.empCooldown--;
                if (this.globalAlertLevel > 0) this.globalAlertLevel--;
            }
            
            createEMPEffect() {
                // EMPエフェクトの視覚表現
                this.empEffect = {
                    x: this.player.x,
                    y: this.player.y,
                    radius: 0,
                    maxRadius: 150,
                    timer: 60
                };
            }
            
            render() {
                switch (this.gameState) {
                    case 'playing':
                    case 'gameOver':
                    case 'areaClear':
                        this.drawGame();
                        break;
                    case 'menu':
                        // メニュー画面では何も描画しない（HTMLで処理）
                        break;
                }

                if (this.gameState === 'gameOver') {
                    this.drawGameOverScreen();
                } else if (this.gameState === 'areaClear') {
                    this.drawAreaClearScreen();
                }
            }

            drawGame() {
                // 背景クリア
                this.ctx.fillStyle = '#001122';
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                // グリッド描画
                this.drawGrid();
                
                // ライト効果
                this.drawLights();
                
                // 安全地帯
                this.drawSafeZones();
                
                // 障害物描画
                this.drawObstacles();
                
                // データポイント描画
                this.drawDataPoints();

                // 出口描画
                this.drawExit();
                
                // セキュリティカメラ描画
                this.drawSecurityCameras();
                
                // 敵描画
                this.drawEnemies();
                
                // プレイヤー描画
                this.drawPlayer();
                
                // エフェクト描画
                this.drawEffects();
                
                // ミニマップ描画
                this.drawMinimap();
                
                // UI更新
                this.updateUI();
            }

            drawGameOverScreen() {
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                this.ctx.fillRect(0, 0, this.width, this.height);
                this.ctx.fillStyle = '#ff0000';
                this.ctx.font = '60px "Courier New", monospace';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('GAME OVER', this.width / 2, this.height / 2);
                this.ctx.fillStyle = '#ffffff';
                this.ctx.font = '24px "Courier New", monospace';
                this.ctx.fillText('Press Enter to Retry', this.width / 2, this.height / 2 + 40);
            }

            drawAreaClearScreen() {
                this.ctx.fillStyle = 'rgba(0, 20, 40, 0.7)';
                this.ctx.fillRect(0, 0, this.width, this.height);
                this.ctx.fillStyle = '#00ff88';
                this.ctx.font = '50px "Courier New", monospace';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('AREA CLEAR!', this.width / 2, this.height / 2);
                this.ctx.fillStyle = '#ffffff';
                this.ctx.font = '24px "Courier New", monospace';
                this.ctx.fillText('Press Enter to Continue', this.width / 2, this.height / 2 + 40);
            }

            drawExit() {
                if (!this.exit) return;

                const screenX = Math.floor(this.exit.x - this.camera.x);
                const screenY = Math.floor(this.exit.y - this.camera.y);

                if (this.isOnScreen(screenX, screenY)) {
                    this.exit.pulse += 0.1;
                    const pulseVal = Math.sin(this.exit.pulse);

                    this.ctx.save();
                    this.ctx.translate(screenX, screenY);
                    this.ctx.rotate(this.exit.pulse * 0.5);

                    const gradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, this.exit.size);
                    gradient.addColorStop(0, `rgba(180, 255, 255, ${0.5 + pulseVal * 0.2})`);
                    gradient.addColorStop(0.8, `rgba(100, 200, 255, ${0.3 + pulseVal * 0.2})`);
                    gradient.addColorStop(1, 'rgba(50, 150, 255, 0)');

                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(-this.exit.size, -this.exit.size, this.exit.size * 2, this.exit.size * 2);
                    
                    this.ctx.strokeStyle = `rgba(200, 255, 255, ${0.8 + pulseVal * 0.2})`;
                    this.ctx.lineWidth = 2;
                    this.ctx.strokeRect(-this.exit.size / 2, -this.exit.size / 2, this.exit.size, this.exit.size);

                    this.ctx.restore();
                }
            }
            
            drawGrid() {
                this.ctx.strokeStyle = '#004466';
                this.ctx.lineWidth = 1;
                
                const gridSize = 50;
                const startX = Math.floor(this.camera.x / gridSize) * gridSize;
                const startY = Math.floor(this.camera.y / gridSize) * gridSize;
                
                for (let x = startX; x < this.camera.x + this.width + gridSize; x += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(Math.floor(x - this.camera.x), 0);
                    this.ctx.lineTo(Math.floor(x - this.camera.x), this.height);
                    this.ctx.stroke();
                }
                
                for (let y = startY; y < this.camera.y + this.height + gridSize; y += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, Math.floor(y - this.camera.y));
                    this.ctx.lineTo(this.width, Math.floor(y - this.camera.y));
                    this.ctx.stroke();
                }
            }
            
            drawLights() {
                this.lights.forEach(light => {
                    const screenX = Math.floor(light.x - this.camera.x);
                    const screenY = Math.floor(light.y - this.camera.y);
                    
                    if (this.isOnScreen(screenX, screenY)) {
                        let intensity = light.intensity;
                        
                        if (light.type === 'strobe') {
                            intensity *= Math.sin(this.gameTime * 0.3) > 0 ? 1 : 0.1;
                        } else {
                            intensity += Math.sin(this.gameTime * 0.05) * light.flicker;
                        }
                        
                        const gradient = this.ctx.createRadialGradient(screenX, screenY, 0, screenX, screenY, light.radius);
                        const color = light.color.replace(/[\d.]+%\)/, `${intensity * 30}%)`);
                        gradient.addColorStop(0, color);
                        gradient.addColorStop(1, 'transparent');
                        
                        this.ctx.fillStyle = gradient;
                        this.ctx.fillRect(screenX - light.radius, screenY - light.radius, light.radius * 2, light.radius * 2);
                    }
                });
            }
            
            drawSafeZones() {
                this.safeZones.forEach(zone => {
                    const screenX = Math.floor(zone.x - this.camera.x);
                    const screenY = Math.floor(zone.y - this.camera.y);
                    
                    if (this.isOnScreen(screenX, screenY)) {
                        zone.pulse += 0.05;
                        const pulseRadius = zone.radius + Math.sin(zone.pulse) * 5;
                        
                        // 安全地帯の表示
                        const gradient = this.ctx.createRadialGradient(screenX, screenY, 0, screenX, screenY, pulseRadius);
                        gradient.addColorStop(0, 'rgba(0, 255, 0, 0.1)');
                        gradient.addColorStop(1, 'rgba(0, 255, 0, 0)');
                        
                        this.ctx.fillStyle = gradient;
                        this.ctx.beginPath();
                        this.ctx.arc(screenX, screenY, pulseRadius, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        // 境界線
                        this.ctx.strokeStyle = '#00ff00';
                        this.ctx.lineWidth = 2;
                        this.ctx.setLineDash([5, 5]);
                        this.ctx.beginPath();
                        this.ctx.arc(screenX, screenY, zone.radius, 0, Math.PI * 2);
                        this.ctx.stroke();
                        this.ctx.setLineDash([]);
                    }
                });
            }
            
            drawObstacles() {
                this.obstacles.forEach(obstacle => {
                    const screenX = Math.floor(obstacle.x - this.camera.x);
                    const screenY = Math.floor(obstacle.y - this.camera.y);
                    
                    if (this.isOnScreen(screenX, screenY)) {
                        // 障害物タイプ別の描画
                        let fillColor, strokeColor;
                        
                        switch (obstacle.type) {
                            case 'building':
                                fillColor = '#2a4a6b';
                                strokeColor = '#4a8acc';
                                break;
                            case 'wall':
                                fillColor = '#3a3a5a';
                                strokeColor = '#6a6aaa';
                                break;
                            case 'annex':
                                fillColor = '#2a3a4a';
                                strokeColor = '#4a6a8a';
                                break;
                            default:
                                fillColor = '#2a4a6b';
                                strokeColor = '#4a8acc';
                        }
                        
                        this.ctx.fillStyle = fillColor;
                        this.ctx.fillRect(screenX, screenY, obstacle.width, obstacle.height);
                        
                        // ネオンの縁取り
                        this.ctx.strokeStyle = strokeColor;
                        this.ctx.lineWidth = 1;
                        this.ctx.strokeRect(screenX, screenY, obstacle.width, obstacle.height);
                        
                        // 建物の詳細
                        if (obstacle.type === 'building' && obstacle.width > 80) {
                            this.ctx.fillStyle = strokeColor;
                            for (let i = 0; i < 3; i++) {
                                for (let j = 0; j < 3; j++) {
                                    const wx = screenX + 10 + (obstacle.width - 20) * i / 3;
                                    const wy = screenY + 10 + (obstacle.height - 20) * j / 3;
                                    this.ctx.fillRect(Math.floor(wx), Math.floor(wy), 8, 8);
                                }
                            }
                        }
                    }
                });
            }
            
            drawDataPoints() {
                this.dataPoints.forEach(data => {
                    if (!data.collected) {
                        const screenX = Math.floor(data.x - this.camera.x);
                        const screenY = Math.floor(data.y - this.camera.y);
                        
                        if (this.isOnScreen(screenX, screenY)) {
                            const pulseSize = 4 + Math.sin(data.pulse) * 2;
                            const alpha = 0.7 + Math.sin(data.pulse * 2) * 0.3;
                            
                            this.ctx.fillStyle = `rgba(0, 255, 255, ${alpha})`;
                            this.ctx.shadowBlur = 0; // シャドウをオフ
                            this.ctx.fillRect(screenX - pulseSize, screenY - pulseSize, pulseSize * 2, pulseSize * 2);
                            
                            // データ値表示
                            if (data.value > 150) {
                                this.ctx.fillStyle = '#ffff00';
                                this.ctx.font = '12px monospace';
                                this.ctx.textAlign = 'center';
                                this.ctx.fillText('!', screenX, screenY - pulseSize - 5);
                            }
                        }
                    }
                });
            }
            
            drawSecurityCameras() {
                this.securityCameras.forEach(camera => {
                    const screenX = Math.floor(camera.x - this.camera.x);
                    const screenY = Math.floor(camera.y - this.camera.y);
                    
                    if (this.isOnScreen(screenX, screenY)) {
                        if (!camera.disabled) {
                            // 視野範囲表示
                            this.ctx.fillStyle = camera.alertState > 0 ? 'rgba(255, 0, 0, 0.15)' : 'rgba(255, 165, 0, 0.1)';
                            this.ctx.beginPath();
                            this.ctx.moveTo(screenX, screenY);
                            this.ctx.arc(screenX, screenY, camera.viewDistance, 
                                        camera.angle - camera.viewAngle / 2, 
                                        camera.angle + camera.viewAngle / 2);
                            this.ctx.closePath();
                            this.ctx.fill();
                        }
                        
                        // カメラ本体
                        this.ctx.fillStyle = camera.disabled ? '#666666' : (camera.alertState > 0 ? '#ff0000' : '#ff6600');
                        this.ctx.shadowBlur = 0;
                        this.ctx.fillRect(screenX - 6, screenY - 6, 12, 12);
                        
                        // レンズ方向
                        if (!camera.disabled) {
                            this.ctx.strokeStyle = '#ffffff';
                            this.ctx.lineWidth = 2;
                            this.ctx.beginPath();
                            this.ctx.moveTo(screenX, screenY);
                            this.ctx.lineTo(Math.floor(screenX + Math.cos(camera.angle) * 20), Math.floor(screenY + Math.sin(camera.angle) * 20));
                            this.ctx.stroke();
                        }
                    }
                });
            }
            
            drawEnemies() {
                this.enemies.forEach(enemy => {
                    const screenX = Math.floor(enemy.x - this.camera.x);
                    const screenY = Math.floor(enemy.y - this.camera.y);
                    
                    if (this.isOnScreen(screenX, screenY)) {
                        if (enemy.alertState >= 0) {
                            // 視野範囲表示
                            let viewColor;
                            if (enemy.alertState > 0) {
                                viewColor = 'rgba(255, 0, 0, 0.25)';
                            } else if (enemy.suspicionLevel > 30) {
                                viewColor = 'rgba(255, 255, 0, 0.15)';
                            } else {
                                viewColor = 'rgba(255, 255, 0, 0.08)';
                            }
                            
                            this.ctx.fillStyle = viewColor;
                            this.ctx.beginPath();
                            this.ctx.moveTo(screenX, screenY);
                            this.ctx.arc(screenX, screenY, enemy.viewDistance, 
                                        enemy.angle - enemy.viewAngle / 2, 
                                        enemy.angle + enemy.viewAngle / 2);
                            this.ctx.closePath();
                            this.ctx.fill();
                        }
                        
                        // 敵本体（タイプ別）
                        let enemyColor;
                        switch (enemy.type) {
                            case 'scout':
                                enemyColor = enemy.alertState > 0 ? '#ff4444' : '#44ff44';
                                break;
                            case 'heavy':
                                enemyColor = enemy.alertState > 0 ? '#ff0000' : '#ff8800';
                                break;
                            default:
                                enemyColor = enemy.alertState > 0 ? '#ff2222' : '#ffaa00';
                        }
                        
                        this.ctx.fillStyle = enemyColor;
                        this.ctx.shadowBlur = 0;
                        this.ctx.fillRect(screenX - enemy.size / 2, screenY - enemy.size / 2, enemy.size, enemy.size);
                        
                        // 向きの表示
                        this.ctx.strokeStyle = '#ffffff';
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.moveTo(screenX, screenY);
                        this.ctx.lineTo(Math.floor(screenX + Math.cos(enemy.angle) * (enemy.size + 4)), 
                                       Math.floor(screenY + Math.sin(enemy.angle) * (enemy.size + 4)));
                        this.ctx.stroke();
                        
                        // 疑惑レベル表示
                        if (enemy.suspicionLevel > 0) {
                            this.ctx.fillStyle = `rgba(255, 255, 0, ${enemy.suspicionLevel / 100})`;
                            this.ctx.fillRect(screenX - enemy.size, screenY - enemy.size - 15, 
                                            (enemy.size * 2) * (enemy.suspicionLevel / 100), 3);
                        }
                    }
                });
            }
            
            drawPlayer() {
                const screenX = Math.floor(this.player.x - this.camera.x);
                const screenY = Math.floor(this.player.y - this.camera.y);
                
                // 安全地帯にいる場合のオーラ
                if (this.isInSafeZone()) {
                    this.ctx.strokeStyle = 'rgba(0, 255, 0, 0.6)';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.rect(screenX - this.player.size / 2 - 3, screenY - this.player.size / 2 - 3, this.player.size + 6, this.player.size + 6);
                    this.ctx.stroke();
                }
                
                if (this.player.stealth) {
                    this.ctx.globalAlpha = 0.3;
                    this.ctx.fillStyle = '#00ffff';
                } else {
                    this.ctx.fillStyle = '#00ff00';
                }
                
                this.ctx.shadowBlur = 0;
                this.ctx.fillRect(screenX - this.player.size / 2, screenY - this.player.size / 2, this.player.size, this.player.size);
                this.ctx.globalAlpha = 1;
                
                // ノイズレベル表示
                if (this.player.noiseLevel > 1) {
                    const noiseRadius = 5 + this.player.noiseLevel * 2;
                    this.ctx.strokeStyle = `rgba(255, 255, 0, ${this.player.noiseLevel / 10})`;
                    this.ctx.lineWidth = 1;
                    this.ctx.beginPath();
                    this.ctx.arc(screenX, screenY, noiseRadius, 0, Math.PI * 2);
                    this.ctx.stroke();
                }
            }
            
            drawEffects() {
                // EMPエフェクト
                if (this.empEffect && this.empEffect.timer > 0) {
                    this.empEffect.radius += (this.empEffect.maxRadius - this.empEffect.radius) * 0.2;
                    this.empEffect.timer--;
                    
                    const screenX = Math.floor(this.empEffect.x - this.camera.x);
                    const screenY = Math.floor(this.empEffect.y - this.camera.y);
                    
                    this.ctx.strokeStyle = `rgba(0, 150, 255, ${this.empEffect.timer / 60})`;
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    this.ctx.arc(screenX, screenY, this.empEffect.radius, 0, Math.PI * 2);
                    this.ctx.stroke();
                    
                    if (this.empEffect.timer <= 0) {
                        this.empEffect = null;
                    }
                }
            }
            
            drawMinimap() {
                const minimapSize = 150;
                const scale = minimapSize / 400; // 400ピクセル範囲をミニマップに表示
                
                this.minimapCtx.fillStyle = 'rgba(0, 17, 34, 0.9)';
                this.minimapCtx.fillRect(0, 0, minimapSize, minimapSize);
                
                const centerX = minimapSize / 2;
                const centerY = minimapSize / 2;
                
                // 障害物
                this.minimapCtx.fillStyle = '#4a8acc';
                this.obstacles.forEach(obstacle => {
                    const relX = (obstacle.x - this.player.x) * scale + centerX;
                    const relY = (obstacle.y - this.player.y) * scale + centerY;
                    const width = obstacle.width * scale;
                    const height = obstacle.height * scale;
                    
                    if (relX > -width && relX < minimapSize && relY > -height && relY < minimapSize) {
                        this.minimapCtx.fillRect(Math.floor(relX), Math.floor(relY), Math.max(1, width), Math.max(1, height));
                    }
                });
                
                // 敵
                this.minimapCtx.fillStyle = '#ff4444';
                this.enemies.forEach(enemy => {
                    const relX = (enemy.x - this.player.x) * scale + centerX;
                    const relY = (enemy.y - this.player.y) * scale + centerY;
                    
                    if (relX > 0 && relX < minimapSize && relY > 0 && relY < minimapSize) {
                        this.minimapCtx.fillRect(Math.floor(relX) - 1, Math.floor(relY) - 1, 3, 3);
                    }
                });
                
                // データポイント
                this.minimapCtx.fillStyle = '#00ffff';
                this.dataPoints.forEach(data => {
                    if (!data.collected) {
                        const relX = (data.x - this.player.x) * scale + centerX;
                        const relY = (data.y - this.player.y) * scale + centerY;
                        
                        if (relX > 0 && relX < minimapSize && relY > 0 && relY < minimapSize) {
                            this.minimapCtx.fillRect(Math.floor(relX) - 1, Math.floor(relY) - 1, 2, 2);
                        }
                    }
                });

                // 出口
                if (this.exit) {
                    this.minimapCtx.fillStyle = '#ffffff';
                    const relX = (this.exit.x - this.player.x) * scale + centerX;
                    const relY = (this.exit.y - this.player.y) * scale + centerY;
                    if (relX > 0 && relX < minimapSize && relY > 0 && relY < minimapSize) {
                        this.minimapCtx.fillRect(Math.floor(relX) - 2, Math.floor(relY) - 2, 4, 4);
                    }
                }
                
                // 安全地帯
                this.minimapCtx.strokeStyle = '#00ff00';
                this.minimapCtx.lineWidth = 1;
                this.safeZones.forEach(zone => {
                    const relX = (zone.x - this.player.x) * scale + centerX;
                    const relY = (zone.y - this.player.y) * scale + centerY;
                    const radius = zone.radius * scale;
                    
                    if (relX > -radius && relX < minimapSize + radius && relY > -radius && relY < minimapSize + radius) {
                        this.minimapCtx.beginPath();
                        this.minimapCtx.arc(Math.floor(relX), Math.floor(relY), radius, 0, Math.PI * 2);
                        this.minimapCtx.stroke();
                    }
                });
                
                // プレイヤー（中央）
                this.minimapCtx.fillStyle = '#00ff00';
                this.minimapCtx.fillRect(centerX - 2, centerY - 2, 4, 4);
                
                // ミニマップの枠
                this.minimapCtx.strokeStyle = '#00ffff';
                this.minimapCtx.lineWidth = 2;
                this.minimapCtx.strokeRect(0, 0, minimapSize, minimapSize);
            }
            
            updateUI() {
                document.getElementById('score').textContent = this.score;
                document.getElementById('data').textContent = this.totalOrbsCollected;
                
                // 現在のレベルの目標値を取得
                const currentTarget = this.currentLevel <= this.levelTargets.length ? 
                                    this.levelTargets[this.currentLevel - 1] : 'MAX';
                document.getElementById('totalData').textContent = currentTarget;
                document.getElementById('level').textContent = this.currentLevel;
                
                const hpBarInner = document.getElementById('hpBarInner');
                const hpPercentage = Math.max(0, this.player.hp / this.player.maxHp) * 100;
                hpBarInner.style.width = `${hpPercentage}%`;
                hpBarInner.style.backgroundColor = hpPercentage > 50 ? '#00ff00' : hpPercentage > 25 ? '#ffff00' : '#ff0000';

                const alertStatus = document.getElementById('alertStatus');
                if (this.globalAlertLevel > 0) {
                    alertStatus.textContent = 'Status: Alert!';
                    alertStatus.style.color = '#ff0000';
                } else {
                    alertStatus.textContent = this.isInSafeZone() ? 'Status: Safe Zone' : 'Status: Stealth Mode';
                    alertStatus.style.color = this.isInSafeZone() ? '#00ff00' : '#00ffff';
                }
                
                document.getElementById('stealth').textContent = this.player.stealthCooldown > 0 ? 
                    `${Math.ceil(this.player.stealthCooldown / 60)}s` : 'Ready';
                document.getElementById('hack').textContent = this.player.hackCooldown > 0 ? 
                    `${Math.ceil(this.player.hackCooldown / 60)}s` : 'Ready';
                document.getElementById('emp').textContent = `x${this.player.empGrenades}`;
                
                const noiseText = this.player.noiseLevel < 1 ? 'Silent' : 
                                this.player.noiseLevel < 3 ? 'Low Noise' :
                                this.player.noiseLevel < 6 ? 'Medium Noise' : 'Loud Noise';
                document.getElementById('noise').textContent = noiseText;
                document.getElementById('noise').style.color = this.player.noiseLevel > 5 ? '#ff0000' : 
                                                             this.player.noiseLevel > 2 ? '#ffff00' : '#00ffff';
            }
            
            isPositionValidInArea(x, y, size, obstacles) {
                for (let obstacle of obstacles) {
                    if (x + size / 2 > obstacle.x && x - size / 2 < obstacle.x + obstacle.width &&
                        y + size / 2 > obstacle.y && y - size / 2 < obstacle.y + obstacle.height) {
                        return false;
                    }
                }
                return true;
            }

            // ユーティリティ関数
            distance(a, b) {
                return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
            }
            
            isValidPosition(x, y, size) {
                for (let obstacle of this.obstacles) {
                    if (x + size / 2 > obstacle.x && x - size / 2 < obstacle.x + obstacle.width &&
                        y + size / 2 > obstacle.y && y - size / 2 < obstacle.y + obstacle.height) {
                        return false;
                    }
                }
                return true;
            }
            
            hasLineOfSightBlocked(from, to) {
                for (let obstacle of this.obstacles) {
                    if (this.lineIntersectsRect(from.x, from.y, to.x, to.y, obstacle)) {
                        return true;
                    }
                }
                return false;
            }
            
            lineIntersectsRect(x1, y1, x2, y2, rect) {
                // より正確な線分と矩形の交差判定
                const left = rect.x;
                const right = rect.x + rect.width;
                const top = rect.y;
                const bottom = rect.y + rect.height;
                
                // 線分の両端が矩形の同じ側にある場合、交差しない
                if ((x1 < left && x2 < left) || (x1 > right && x2 > right) ||
                    (y1 < top && y2 < top) || (y1 > bottom && y2 > bottom)) {
                    return false;
                }
                
                // より詳細な交差判定が必要な場合は、線分方程式を使用
                const dx = x2 - x1;
                const dy = y2 - y1;
                
                if (dx === 0) { // 垂直線
                    return x1 >= left && x1 <= right && 
                           Math.max(y1, y2) >= top && Math.min(y1, y2) <= bottom;
                }
                
                const m = dy / dx;
                const c = y1 - m * x1;
                
                // 矩形の4辺との交点をチェック
                let t;
                // 上辺
                t = (top - c) / m;
                if (t >= left && t <= right && t >= Math.min(x1, x2) && t <= Math.max(x1, x2)) return true;
                // 下辺
                t = (bottom - c) / m;
                if (t >= left && t <= right && t >= Math.min(x1, x2) && t <= Math.max(x1, x2)) return true;
                // 左辺
                t = m * left + c;
                if (t >= top && t <= bottom && t >= Math.min(y1, y2) && t <= Math.max(y1, y2)) return true;
                // 右辺
                t = m * right + c;
                if (t >= top && t <= bottom && t >= Math.min(y1, y2) && t <= Math.max(y1, y2)) return true;
                
                return false;
            }
            
            isOnScreen(x, y) {
                return x > -100 && x < this.width + 100 && y > -100 && y < this.height + 100;
            }
            
            hashCode(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash |= 0; // 32bit整数に変換
                }
                return hash;
            }
            
            seededRandom(seed) {
                let s = seed;
                return function() {
                    s = Math.sin(s) * 10000;
                    return s - Math.floor(s);
                };
            }
            
            getRandomNeonColor(rng) {
                const colors = [
                    'hsla(180, 100%, 50%, 0.1)', // Cyan
                    'hsla(300, 100%, 50%, 0.1)', // Magenta
                    'hsla(60, 100%, 50%, 0.1)',  // Yellow
                    'hsla(0, 100%, 50%, 0.1)',   // Red
                    'hsla(240, 100%, 60%, 0.1)'  // Blue
                ];
                return colors[Math.floor(rng() * colors.length)];
            }
            
            gameLoop() {
                if (this.gameState === 'playing') {
                    this.update();
                }
                this.render();
                this.gameLoopId = requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        window.onload = () => {
            new EnhancedNeonInfiltrator();
        };
    </script>
</body>
</html>
